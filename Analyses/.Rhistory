library(phia)
library(DescTools)
library(scales)
#the "utilities" file contains functions so this analysis page isn't too cluttered
source("../Analyses/Utilities.r")
load(file = "../Data/Processed_Data_for_Pgls.rda")
data_raw=read.csv("../Data/raw_data.csv", header=TRUE)
DataQuality=as.data.frame(sapply(data_raw[,2:28], function(x) sum((!is.na(x))/nrow(data_raw))*100))
colnames(DataQuality)=c ("% in raw dataset")
DataQuality
View(data)
View(data_raw)
View(data)
data_for_mid_checks<-data
#if there are male/female ranges, provide their mean; this is clunky but I prefer to have the names written out to reduce human error in assigning column numbers
for (i in 1:length(data$Species)){
#if there are min/max values for males and females, average them unless an average is already given; this code here separates M/F because sometimes ranges are only given for one sex
if(is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Wt_min_M[i])==FALSE & is.na(data$Wt_Av_M[i]==TRUE)){
data_for_mid_checks$Wt_Av_M[i]<-mean(c(data$Wt_min_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE & is.na(data$Bl_Av_F[i]==TRUE)){
data_for_mid_checks$Bl_Av_F[i]<-mean(c(data$Bl_min_F[i],data$Bl_max_F[i]))
}
if(is.na(data$Bl_min_M[i])==FALSE & is.na(data$Bl_Av_M[i]==TRUE)){
data_for_mid_checks$Bl_Av_M[i]<-mean(c(data$Bl_min_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE & is.na(data$Tl_Av_F[i]==TRUE)){
data_for_mid_checks$Tl_Av_F[i]<-mean(c(data$Tl_min_F[i],data$Tl_max_F[i]))
}
if(is.na(data$Tl_min_M[i])==FALSE & is.na(data$Tl_Av_M[i]==TRUE)){
data_for_mid_checks$Tl_Av_M[i]<-mean(c(data$Tl_min_M[i],data$Tl_max_M[i]))
}
# if males or females have ranges, enter the max and min for each species in the relevant column; this assumes that overall ranges are never given together with the more informative range values by sex
if((is.na(data$Wt_min_F[i])==FALSE | is.na(data$Wt_min_M[i])==FALSE)){
data_for_mid_checks$Wt_min[i]<-min(c(data$Wt_min_F[i],data$Wt_max_F[i],data$Wt_min_M[i],data$Wt_max_M[i]))
data_for_mid_checks$Wt_max[i]<-max(c(data$Wt_max_F[i],data$Wt_max_F[i],data$Wt_max_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE | is.na(data$Bl_min_M[i])==FALSE){
data_for_mid_checks$Bl_min[i]<-min(c(data$Bl_min_F[i],data$Bl_max_F[i],data$Bl_min_M[i],data$Bl_max_M[i]))
data_for_mid_checks$Bl_max[i]<-max(c(data$Bl_max_F[i],data$Bl_max_F[i],data$Bl_max_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE | is.na(data$Tl_min_M[i])==FALSE){
data_for_mid_checks$Tl_min[i]<-min(c(data$Tl_min_F[i],data$Tl_max_F[i],data$Tl_min_M[i],data$Tl_max_M[i]))
data_for_mid_checks$Tl_max[i]<-max(c(data$Tl_max_F[i],data$Tl_max_F[i],data$Tl_max_M[i],data$Tl_max_M[i]))
}
}
is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE)
which(is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE))
which(is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE))
which(is.na(data$Wt_min_F)==FALSE & is.na(data$Wt_Av_F==TRUE))
which(is.na(data$Wt_min_F)==FALSE & is.na(data$Wt_Av_F==TRUE))
is.na(data$Wt_min_F)==FALSE
which(is.na(data$Wt_min_F)==FALSE)
which(is.na(data$Wt_min_F)==FALSE)
which(is.na(data$Wt_min_F)==FALSE& is.na(data$Wt_Av_F==TRUE))
which(is.na(data$Wt_min_F)==FALSE)
which(is.na(data$Wt_Av_F==TRUE)
which(is.na(data$Wt_Av_F==TRUE))
which(is.na(data$Wt_Av_F==TRUE)
which(is.na(data$Wt_Av_F==TRUE))
which(is.na(data$Wt_Av_F)==TRUE))
which(is.na(data$Wt_Av_F)==TRUE)
#if there are male/female ranges, provide their mean; this is clunky but I prefer to have the names written out to reduce human error in assigning column numbers
for (i in 1:length(data$Species)){
#if there are min/max values for males and females, average them unless an average is already given; this code here separates M/F because sometimes ranges are only given for one sex
if(is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Wt_min_M[i])==FALSE & is.na(data$Wt_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Bl_min_F[i])==FALSE & is.na(data$Bl_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Bl_min_M[i])==FALSE & is.na(data$Bl_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Tl_min_F[i])==FALSE & is.na(data$Tl_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Tl_min_M[i])==FALSE & is.na(data$Tl_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
# if males or females have ranges, enter the max and min for each species in the relevant column; this assumes that overall ranges are never given together with the more informative range values by sex
if((is.na(data$Wt_min_F[i])==FALSE | is.na(data$Wt_min_M[i])==FALSE)){
data_for_mid_checks$Wt_min[i]<-min(c(data$Wt_min_F[i],data$Wt_max_F[i],data$Wt_min_M[i],data$Wt_max_M[i]))
data_for_mid_checks$Wt_max[i]<-max(c(data$Wt_max_F[i],data$Wt_max_F[i],data$Wt_max_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE | is.na(data$Bl_min_M[i])==FALSE){
data_for_mid_checks$Bl_min[i]<-min(c(data$Bl_min_F[i],data$Bl_max_F[i],data$Bl_min_M[i],data$Bl_max_M[i]))
data_for_mid_checks$Bl_max[i]<-max(c(data$Bl_max_F[i],data$Bl_max_F[i],data$Bl_max_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE | is.na(data$Tl_min_M[i])==FALSE){
data_for_mid_checks$Tl_min[i]<-min(c(data$Tl_min_F[i],data$Tl_max_F[i],data$Tl_min_M[i],data$Tl_max_M[i]))
data_for_mid_checks$Tl_max[i]<-max(c(data$Tl_max_F[i],data$Tl_max_F[i],data$Tl_max_M[i],data$Tl_max_M[i]))
}
}
data_for_mid_check_compare <- data
data_for_mid_checks<-data
#if there are male/female ranges, provide their mean; this is clunky but I prefer to have the names written out to reduce human error in assigning column numbers
for (i in 1:length(data$Species)){
#if there are min/max values for males and females, average them unless an average is already given; this code here separates M/F because sometimes ranges are only given for one sex
if(is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Wt_min_M[i])==FALSE & is.na(data$Wt_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Bl_min_F[i])==FALSE & is.na(data$Bl_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Bl_min_M[i])==FALSE & is.na(data$Bl_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Tl_min_F[i])==FALSE & is.na(data$Tl_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Tl_min_M[i])==FALSE & is.na(data$Tl_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
# if males or females have ranges, enter the max and min for each species in the relevant column; this assumes that overall ranges are never given together with the more informative range values by sex
if((is.na(data$Wt_min_F[i])==FALSE | is.na(data$Wt_min_M[i])==FALSE)){
data_for_mid_checks$Wt_min[i]<-min(c(data$Wt_min_F[i],data$Wt_max_F[i],data$Wt_min_M[i],data$Wt_max_M[i]))
data_for_mid_checks$Wt_max[i]<-max(c(data$Wt_max_F[i],data$Wt_max_F[i],data$Wt_max_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE | is.na(data$Bl_min_M[i])==FALSE){
data_for_mid_checks$Bl_min[i]<-min(c(data$Bl_min_F[i],data$Bl_max_F[i],data$Bl_min_M[i],data$Bl_max_M[i]))
data_for_mid_checks$Bl_max[i]<-max(c(data$Bl_max_F[i],data$Bl_max_F[i],data$Bl_max_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE | is.na(data$Tl_min_M[i])==FALSE){
data_for_mid_checks$Tl_min[i]<-min(c(data$Tl_min_F[i],data$Tl_max_F[i],data$Tl_min_M[i],data$Tl_max_M[i]))
data_for_mid_checks$Tl_max[i]<-max(c(data$Tl_max_F[i],data$Tl_max_F[i],data$Tl_max_M[i],data$Tl_max_M[i]))
}
}
data_for_mid_check_compare <- data
data_for_mid_checks<-data
#if there are male/female ranges, provide their mean; this is clunky but I prefer to have the names written out to reduce human error in assigning column numbers
for (i in 1:length(data$Species)){
#if there are min/max values for males and females, average them unless an average is already given; this code here separates M/F because sometimes ranges are only given for one sex
if(is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Wt_min_M[i])==FALSE & is.na(data$Wt_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Bl_min_F[i])==FALSE & is.na(data$Bl_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Bl_min_M[i])==FALSE & is.na(data$Bl_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Tl_min_F[i])==FALSE & is.na(data$Tl_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Tl_min_M[i])==FALSE & is.na(data$Tl_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
# if males or females have ranges, enter the max and min for each species in the relevant column; this assumes that overall ranges are never given together with the more informative range values by sex
if((is.na(data$Wt_min_F[i])==FALSE | is.na(data$Wt_min_M[i])==FALSE)){
data_for_mid_checks$Wt_min[i]<-min(c(data$Wt_min_F[i],data$Wt_max_F[i],data$Wt_min_M[i],data$Wt_max_M[i]))
data_for_mid_checks$Wt_max[i]<-max(c(data$Wt_max_F[i],data$Wt_max_F[i],data$Wt_max_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE | is.na(data$Bl_min_M[i])==FALSE){
data_for_mid_checks$Bl_min[i]<-min(c(data$Bl_min_F[i],data$Bl_max_F[i],data$Bl_min_M[i],data$Bl_max_M[i]))
data_for_mid_checks$Bl_max[i]<-max(c(data$Bl_max_F[i],data$Bl_max_F[i],data$Bl_max_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE | is.na(data$Tl_min_M[i])==FALSE){
data_for_mid_checks$Tl_min[i]<-min(c(data$Tl_min_F[i],data$Tl_max_F[i],data$Tl_min_M[i],data$Tl_max_M[i]))
data_for_mid_checks$Tl_max[i]<-max(c(data$Tl_max_F[i],data$Tl_max_F[i],data$Tl_max_M[i],data$Tl_max_M[i]))
}
}
length(data_for_mid_check_compare$Species)
length(data_for_mid_checks$Species)
data_for_mid_checks$Species[34]
data_for_mid_check_compare <- data
data_for_mid_check_compare <- data.raw
data_for_mid_check_compare <- data_raw
data_for_mid_checks<-data_raw
#if there are male/female ranges, provide their mean; this is clunky but I prefer to have the names written out to reduce human error in assigning column numbers
for (i in 1:length(data$Species)){
#if there are min/max values for males and females, but no average is given, delete
if(is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Wt_min_M[i])==FALSE & is.na(data$Wt_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Bl_min_F[i])==FALSE & is.na(data$Bl_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Bl_min_M[i])==FALSE & is.na(data$Bl_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Tl_min_F[i])==FALSE & is.na(data$Tl_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Tl_min_M[i])==FALSE & is.na(data$Tl_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
# if males or females have ranges, enter the max and min for each species in the relevant column; this assumes that overall ranges are never given together with the more informative range values by sex
if((is.na(data$Wt_min_F[i])==FALSE | is.na(data$Wt_min_M[i])==FALSE)){
data_for_mid_checks$Wt_min[i]<-min(c(data$Wt_min_F[i],data$Wt_max_F[i],data$Wt_min_M[i],data$Wt_max_M[i]))
data_for_mid_checks$Wt_max[i]<-max(c(data$Wt_max_F[i],data$Wt_max_F[i],data$Wt_max_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE | is.na(data$Bl_min_M[i])==FALSE){
data_for_mid_checks$Bl_min[i]<-min(c(data$Bl_min_F[i],data$Bl_max_F[i],data$Bl_min_M[i],data$Bl_max_M[i]))
data_for_mid_checks$Bl_max[i]<-max(c(data$Bl_max_F[i],data$Bl_max_F[i],data$Bl_max_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE | is.na(data$Tl_min_M[i])==FALSE){
data_for_mid_checks$Tl_min[i]<-min(c(data$Tl_min_F[i],data$Tl_max_F[i],data$Tl_min_M[i],data$Tl_max_M[i]))
data_for_mid_checks$Tl_max[i]<-max(c(data$Tl_max_F[i],data$Tl_max_F[i],data$Tl_max_M[i],data$Tl_max_M[i]))
}
}
#check that the reduction worked:
length(data_for_mid_check_compare$Species)
length(data_for_mid_checks$Species)
data=read.csv("../Data/raw_data.csv", header=TRUE)
data_for_mid_check_compare <- data
data_for_mid_checks<-data
#if there are male/female ranges, provide their mean; this is clunky but I prefer to have the names written out to reduce human error in assigning column numbers
for (i in 1:length(data$Species)){
#if there are min/max values for males and females, but no average is given, delete
if(is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Wt_min_M[i])==FALSE & is.na(data$Wt_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Bl_min_F[i])==FALSE & is.na(data$Bl_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Bl_min_M[i])==FALSE & is.na(data$Bl_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Tl_min_F[i])==FALSE & is.na(data$Tl_Av_F[i]==TRUE)){
data_for_mid_checks[-i,]
}
if(is.na(data$Tl_min_M[i])==FALSE & is.na(data$Tl_Av_M[i]==TRUE)){
data_for_mid_checks[-i,]
}
# if males or females have ranges, enter the max and min for each species in the relevant column; this assumes that overall ranges are never given together with the more informative range values by sex
if((is.na(data$Wt_min_F[i])==FALSE | is.na(data$Wt_min_M[i])==FALSE)){
data_for_mid_checks$Wt_min[i]<-min(c(data$Wt_min_F[i],data$Wt_max_F[i],data$Wt_min_M[i],data$Wt_max_M[i]))
data_for_mid_checks$Wt_max[i]<-max(c(data$Wt_max_F[i],data$Wt_max_F[i],data$Wt_max_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE | is.na(data$Bl_min_M[i])==FALSE){
data_for_mid_checks$Bl_min[i]<-min(c(data$Bl_min_F[i],data$Bl_max_F[i],data$Bl_min_M[i],data$Bl_max_M[i]))
data_for_mid_checks$Bl_max[i]<-max(c(data$Bl_max_F[i],data$Bl_max_F[i],data$Bl_max_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE | is.na(data$Tl_min_M[i])==FALSE){
data_for_mid_checks$Tl_min[i]<-min(c(data$Tl_min_F[i],data$Tl_max_F[i],data$Tl_min_M[i],data$Tl_max_M[i]))
data_for_mid_checks$Tl_max[i]<-max(c(data$Tl_max_F[i],data$Tl_max_F[i],data$Tl_max_M[i],data$Tl_max_M[i]))
}
}
#check that the reduction worked:
length(data_for_mid_check_compare$Species)
length(data_for_mid_checks$Species)
data_for_mid_checks[34,]
data_for_mid_checks[34,]
is.na(data$Wt_min_F[34])==FALSE
is.na(data$Wt_min_F[35])==FALSE
is.na(data$Wt_Av_F[35]==TRUE
is.na(data$Wt_Av_F[35])==TRUE
data[35,]
data[33,]
is.na(data$Wt_min_F[33])==FALSE
is.na(data$Wt_Av_F[3])==TRUE
is.na(data$Wt_Av_F[33])==TRUE
is.na(data$Wt_min_F[33])==FALSE & is.na(data$Wt_Av_F[33])==TRUE
which(is.na(data$Wt_min_F)==FALSE & is.na(data$Wt_Av_F)==TRUE)
which(is.na(data$Wt_min_F)==FALSE & is.na(data$Wt_Av_F)==TRUE)
which(is.na(data$Wt_min_M[i])==FALSE & is.na(data$Wt_Av_M[i]==TRUE)
#Summary
summary(lm(pca_general$pc.scores[,1]  ~meta.info$Csize))
library(dplyr)
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
data.raw <- read.csv("../1_Data (original data)/1_Raw/02_O_ana_-_Landmark_Data.csv", header = T)
data <- data.raw[, 2:(dim(data.raw)[2])]  # removes LM names for geomorph
data <- t(data)
A_ERR <- arrayspecs(data, 135, 3,sep = NULL)  # convert to 3D array w 405 pts & 3D coords
plot3d(A_ERR[,,1], asp=FALSE) #Check the landmarks have come through ok
# Detect replicates
names <- dimnames(A_ERR)[[3]]
isrep <- which(str_detect(names, "_ERR"))
# Removing Replicates
specimens <- c(1:length(dimnames(A_ERR)[[3]]))
notrep <- is.na(match(specimens, isrep))
A <- A_ERR[ , ,notrep]
WriteMetadata <- function(threeD.array, cols) {
# Makes metadata table from specimen filenames for shape coordinates.
#
# Args:
#    threeD.array: 3D array (p x k x n), where p is the number of landmarks, k is the dimension (3), and n is the number of specimens. Assumes the 1st column of landmark names has been removed.
#    cols: a character vector of column names of length n-1, where n is the number of underscores separating metadata information in the specimen filenames. Assumes filenames contain information in the same order and the appropriate names are given in this order in cols.
#
# Returns:
#    A dataframe containing the metadata for each specimen in the same order as specimens in the 3D array of shape data.
# Remove 'ind' that bilat.symmetry() appends to specimen names
names <- gsub("ind", "", dimnames(threeD.array)[[3]])
names <- gsub("_non","",names)
names <- gsub("_ERR", "",names)
# Convert name vectors into data frame
categories <- strsplit(names, "_")
my.classifiers <- matrix(unlist(categories), ncol = length(cols), byrow = T)
colnames(my.classifiers) <- cols
sp.info <- as.data.frame(my.classifiers)
return(sp.info)
}
cols = c("Genus", "Species","Museum", "CatNum")
sp.info <- WriteMetadata(A, cols)
# Add special columns (requires 'Genus' 'Species' & 'CatNum')
sp.info$Taxa <- paste(str_sub(sp.info$Genus, 1, 1), str_sub(sp.info$Species, 1, 3), sep = "_")  # turns Ornithorhynchus anatinus into O_ana
sp.info$All <- with(sp.info, interaction(Genus, Species, Museum, CatNum, sep = "_"))  # required to run geomorph's bilat.symmetry()
# Extract landmark point names
pt.names <-as.vector(data.raw[, 1])  # gets 3D point names from Viewbox
no.XYZ <- str_sub(pt.names, 3,-1)  # removes XYZ appended by Viewbox
no.XYZ.2 <- str_remove(pt.names, " [XYZ]")
u.pt.names<- unique(no.XYZ)  # returns unique point and curve names
Y <- gpagen(A, Proj = TRUE, ProcD = TRUE)
#Check that metadata and Csize match - this should return "TRUE" for all
names(Y$Csize)==sp.info$All
sp.info$Csize <- unname(Y$Csize)
FindPairs <- function(pt.names){
# Creates table of paired bilateral landmarks for bilat.symmetry().
#
# Args:
#   pt.names: a character vector of landmark names.
#
# Returns:
#   2 column data table of paired landmarks ready for geomorph's bilat.symmetry()'s land.pair argument.
pairs <- NULL
# Removes R and L designations so pairs can be detected
no.side.names <- gsub("_R_", "_", pt.names)
no.side.names <- gsub("_L_", "_", no.side.names)
# Checks if point has a pair and if so, their index #s are paired
for(i in unique(no.side.names)){
index <- which(no.side.names == i)
if (length(index) == 2) {
pairs <- rbind(pairs, t(index))
}
}
return(pairs)
}
# Make landmark pair tables for each protocol
land.pairs <- FindPairs(u.pt.names)
# Perform bilateral procrustes alignment on each patch protocol
biY <- bilat.symmetry(Y$coords, ind = sp.info$All, object.sym = T, replicate = NULL, side = NULL, land.pairs = land.pairs)
# Extract symmetric component of shape data
bY.shape <- biY$symm.shape  # analogous to Y$coords, where Y is the output of gpagen()
dimnames(biY$symm.shape) #Double checking the names
names(Y$Csize)
summary(biY)
meanspec=unname(findMeanSpec(bY.shape))
summary(meanspec)
par <- gridPar(pt.bg="pink", pt.size = 1)
#Ensure that sp.infor and bY.shape have the specimens in the same order, which they do not by default because bilat.symm changes the order.
#Secondly take out the "ind" that is left over from the bilat symm operation; this makes the dimnames comparable to sp.info$All
dimnames(bY.shape)[[3]] <- sub(".*ind", "", dimnames(bY.shape)[[3]])
#If the below gives numbers but no NA, we are OK to re-order
match(dimnames(bY.shape)[[3]],sp.info$All)
#Here it is important that you match dimnames with sp.info$All, not the other way around
sp.infoOrdered <- sp.info[match(dimnames(bY.shape)[[3]],sp.info$All),]
#The below has to be TRUE for all if the re-ordering worked.
sp.infoOrdered$All==dimnames(bY.shape)[[3]]
#Change "Mainland" to "East Coast"
levels(meta.info$Population)[levels(meta.info$Population)=="Mainland"] <- "East Coast"
#Double check Csize range
Csizeorder<-sort((meta.info$Csize), decreasing=TRUE)
#Plot centroid size with PC1
plot(pca_general$pc.scores[,1] ~meta.info$Csize, xlab = "Centroid Size", ylab = "PC1",)
# Plot 3D shape into a PCA plot
pca_general <- plotTangentSpace(bY.shape)
#Summary of PCA
pca_general$pc.summary
#Look at difference
plotRefToTarget(pca_general$pc.shapes$PC1min,pca_general$pc.shapes$PC1max, method="vector",pt.bg="pink")
#Make a colour key for popluation
colour_pca_pop <- c("Red", "Black", "Blue", "Green")
grp <- as.factor(meta.info$Population)
library(png)  # needed to work with screenshots
library(geomorph)
library(dplyr)
library(stringr)
library(stringi)
library(devtools)
library(dispRity)
library(landvR)
# Load libraries (and install if necessary) for landvR package
if(!require(devtools)) install.packages("devtools")
if(!require(dispRity)) install.packages("dispRity")
if(!require(landvR)) install_github("TGuillerme/landvR")
data.raw <- read.csv("../1_Data (original data)/1_Raw/02_O_ana_-_Landmark_Data.csv", header = T)
data <- data.raw[, 2:(dim(data.raw)[2])]  # removes LM names for geomorph
data <- t(data)
A_ERR <- arrayspecs(data, 135, 3,sep = NULL)  # convert to 3D array w 405 pts & 3D coords
plot3d(A_ERR[,,1], asp=FALSE) #Check the landmarks have come through ok
# Find mean configuration - i.e. mean shape in dataset
consensus <- (select.procrustes(Y, selector = mean))[[1]]
# Measure spherical coordinates differences from the mean for each specimen for each landmark
diff.from.mean <- coordinates.difference(coordinates = Y$coords, reference = Y$consensus, type = "spherical")
# Ordinate the data
twoD.shape <- two.d.array(Y$coords)
ordination <- stats::prcomp(twoD.shape)
# Force the symmetric component of shape into class "gpagen" (required for variation.range)
gpagen.shape <- list()
gpagen.shape$coords <- Y$coords
gpagen.shape$consensus <- Y$consensus
class(gpagen.shape) <- "gpagen"
# Measure extremes of variation from mean on PC1
PC1.var <- variation.range(gpagen.shape, return.ID = FALSE, axis = 1, ordination = ordination, type = "spherical")
# Wrap specimens on the tangent space
wrap.PCA <- plotTangentSpace(Y$coords, verbose = FALSE)
# Select extreme specimens (the ones that make the warp-meshes)
hypothetical.1 <- wrap.PCA$pc.shapes[[1]]
hypothetical.2 <- wrap.PCA$pc.shapes[[2]]
# PC1 Heatmap
open3d(windowRect = c(0, 0, 600, 600))
PC1.var.plot <- procrustes.var.plot(hypothetical.1, hypothetical.2, col = heat.colors, col.val = PC1.var[, "radius"], labels = F)
view3d(phi = 0)
# Select extreme specimens (the ones that make the warp-meshes)
hypothetical.1 <- wrap.PCA$pc.shapes[[1]]
# Select extreme specimens (the ones that make the warp-meshes)
hypothetical.1 <- wrap.PCA$pc.shapes[[1]]
hypothetical.2 <- wrap.PCA$pc.shapes[[2]]
wrap.PCA$pc.shapes
which(is.na(data$Wt_min_M)==FALSE & is.na(data$Wt_Av_M==TRUE)
)
which(is.na(data$Wt_min_F)==FALSE & is.na(data$Wt_Av_F)==TRUE
which(is.na(data$Wt_min_F)==FALSE & is.na(data$Wt_Av_F)==TRUE)
which(is.na(data$Wt_min_F)==FALSE & is.na(data$Wt_Av_F)==TRUE)
is.na(data$Wt_min_F)==FALSE
data=read.csv("../Data/raw_data.csv", header=TRUE)
#make a matrix for all data but also add 3 columns for final Tl, Bl and Wt
#data_processed<-matrix(ncol=(ncol(data)), nrow=nrow(data))
#colnames(data_processed)<-c(colnames(data))
#rownames(data_processed)<-data$Species
# turn into data frame to feed into loop;
data_processed<-data
#if there are male/female ranges, provide their mean; this is clunky but I prefer to have the names written out to reduce human error in assigning column numbers
for (i in 1:length(data$Species)){
#if there are min/max values for males and females, average them unless an average is already given; this code here separates M/F because sometimes ranges are only given for one sex
if(is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE)){
data_processed$Wt_Av_F[i]<-mean(c(data$Wt_min_F[i],data$Wt_max_F[i]))
}
if(is.na(data$Wt_min_M[i])==FALSE & is.na(data$Wt_Av_M[i]==TRUE)){
data_processed$Wt_Av_M[i]<-mean(c(data$Wt_min_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE & is.na(data$Bl_Av_F[i]==TRUE)){
data_processed$Bl_Av_F[i]<-mean(c(data$Bl_min_F[i],data$Bl_max_F[i]))
}
if(is.na(data$Bl_min_M[i])==FALSE & is.na(data$Bl_Av_M[i]==TRUE)){
data_processed$Bl_Av_M[i]<-mean(c(data$Bl_min_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE & is.na(data$Tl_Av_F[i]==TRUE)){
data_processed$Tl_Av_F[i]<-mean(c(data$Tl_min_F[i],data$Tl_max_F[i]))
}
if(is.na(data$Tl_min_M[i])==FALSE & is.na(data$Tl_Av_M[i]==TRUE)){
data_processed$Tl_Av_M[i]<-mean(c(data$Tl_min_M[i],data$Tl_max_M[i]))
}
# if males or females have ranges, enter the max and min for each species in the relevant column; this assumes that overall ranges are never given together with the more informative range values by sex
if((is.na(data$Wt_min_F[i])==FALSE | is.na(data$Wt_min_M[i])==FALSE)){
data_processed$Wt_min[i]<-min(c(data$Wt_min_F[i],data$Wt_max_F[i],data$Wt_min_M[i],data$Wt_max_M[i]))
data_processed$Wt_max[i]<-max(c(data$Wt_max_F[i],data$Wt_max_F[i],data$Wt_max_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE | is.na(data$Bl_min_M[i])==FALSE){
data_processed$Bl_min[i]<-min(c(data$Bl_min_F[i],data$Bl_max_F[i],data$Bl_min_M[i],data$Bl_max_M[i]))
data_processed$Bl_max[i]<-max(c(data$Bl_max_F[i],data$Bl_max_F[i],data$Bl_max_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE | is.na(data$Tl_min_M[i])==FALSE){
data_processed$Tl_min[i]<-min(c(data$Tl_min_F[i],data$Tl_max_F[i],data$Tl_min_M[i],data$Tl_max_M[i]))
data_processed$Tl_max[i]<-max(c(data$Tl_max_F[i],data$Tl_max_F[i],data$Tl_max_M[i],data$Tl_max_M[i]))
}
}
#now re-process data_processed to fill NAs in the species means, first by averaging male/female values, second (if sex averages are not available) by averaging sex-less min/max values. This overwrites the first pass summary version of data_processed with the second pass summary version
for (i in 1:(nrow(data_processed))){
#if there is a male/female average value, use its average as final value (assuming that female ranges also mean that there is a male range)
if(is.na(data_processed$Wt_g[i])==TRUE & is.na(data_processed$Wt_Av_F[i])==FALSE){
data_processed$Wt_g[i]<-mean(c(data_processed$Wt_Av_F[i], data_processed$Wt_Av_M[i]))
}
if(is.na(data_processed$Bl_mm[i])==TRUE & is.na(data_processed$Bl_Av_F[i])==FALSE){
data_processed$Bl_mm[i]<-mean(c(data_processed$Bl_Av_F[i], data_processed$Bl_Av_M[i]))
}
if(is.na(data_processed$Tl_mm[i])==TRUE & is.na(data_processed$Tl_Av_F[i])==FALSE){
data_processed$Tl_mm[i]<-mean(c(data_processed$Tl_Av_F[i], data_processed$Tl_Av_M[i]))
}
#if there are no male/female average values (regardless of newly created above or originally in the book; i.e. the male and female), average the ranges
if(is.na(data_processed$Wt_g[i])==TRUE & is.na(data_processed$Wt_Av_F[i])==TRUE){
data_processed$Wt_g[i]<-mean(c(data_processed$Wt_max[i], data_processed$Wt_min[i]))
}
if(is.na(data_processed$Bl_mm[i])==TRUE & is.na(data_processed$Bl_Av_F[i])==TRUE){
data_processed$Bl_mm[i]<-mean(c(data_processed$Bl_max[i], data_processed$Bl_min[i]))
}
if(is.na(data_processed$Tl_mm[i])==TRUE & is.na(data_processed$Tl_Av_F[i])==TRUE){
data_processed$Tl_mm[i]<-mean(c(data_processed$Tl_max[i], data_processed$Tl_min[i]))
}
}
#clean up environment
remove(i)
#Write the csv; row.names need to be FALSE because otherwise it saves with an extra column of numbers
write.csv(data_processed, file="../Data/Full_dataset.csv", row.names=FALSE)
data_for_mid_check_compare <- data
data[33,]
is.na(data$Wt_min_F[33])==FALSE & is.na(data$Wt_Av_F[33])==TRUE
which(is.na(data$Wt_min_F)==FALSE & is.na(data$Wt_Av_F)==TRUE)
which(is.na(data$Wt_min_M)==FALSE & is.na(data$Wt_Av_M==TRUE)
which(is.na(data$Wt_min_M)==FALSE & is.na(data$Wt_Av_M)==TRUE)
