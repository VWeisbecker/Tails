data=read.csv("TableCode_example.csv", header=TRUE)
write.csv(data_processed, file="../Data/Full_dataset.csv")
data=read.csv("TableCode_example.csv", header=TRUE)
data=read.csv("TableCode_example.csv", header=TRUE)
#make a matrix for all data but also add 3 columns for final Tl, Bl and Wt
#data_processed<-matrix(ncol=(ncol(data)), nrow=nrow(data))
#colnames(data_processed)<-c(colnames(data))
#rownames(data_processed)<-data$Species
# turn into data frame to feed into loop;
data_processed<-data
#if there are male/female ranges, provide their mean; this is clunky but I prefer to have the names written out to reduce human error in assigning column numbers
for (i in 1:length(data$Species)){
#if there are min/max values for males and females, average them unless an average is already given; this separates M/F because sometimes ranges are only given for one sex
if(is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE)){
data_processed$Wt_Av_F[i]<-mean(c(data$Wt_min_F[i],data$Wt_max_F[i]))
}
if(is.na(data$Wt_min_M[i])==FALSE & is.na(data$Wt_Av_M[i]==TRUE)){
data_processed$Wt_Av_M[i]<-mean(c(data$Wt_min_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE & is.na(data$Bl_Av_F[i]==TRUE)){
data_processed$Bl_Av_F[i]<-mean(c(data$Bl_min_F[i],data$Bl_max_F[i]))
}
if(is.na(data$Bl_min_M[i])==FALSE & is.na(data$Bl_Av_M[i]==TRUE)){
data_processed$Bl_Av_M[i]<-mean(c(data$Bl_min_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE & is.na(data$Tl_Av_F[i]==TRUE)){
data_processed$Tl_Av_F[i]<-mean(c(data$Tl_min_F[i],data$Tl_max_F[i]))
}
if(is.na(data$Tl_min_M[i])==FALSE & is.na(data$Tl_Av_M[i]==TRUE)){
data_processed$Tl_Av_M[i]<-mean(c(data$Tl_min_M[i],data$Tl_max_M[i]))
}
# if males or females have ranges, enter the max and min for each species in the relevant column; this assumes that overall ranges are never given together with the more informative values by sex
if((is.na(data$Wt_min_F[i])==FALSE | is.na(data$Wt_min_M[i])==FALSE)){
data_processed$Wt_min[i]<-min(c(data$Wt_min_F[i],data$Wt_max_F[i],data$Wt_min_M[i],data$Wt_max_M[i]))
data_processed$Wt_max[i]<-max(c(data$Wt_max_F[i],data$Wt_max_F[i],data$Wt_max_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE | is.na(data$Bl_min_M[i])==FALSE){
data_processed$Bl_min[i]<-min(c(data$Bl_min_F[i],data$Bl_max_F[i],data$Bl_min_M[i],data$Bl_max_M[i]))
data_processed$Bl_max[i]<-max(c(data$Bl_max_F[i],data$Bl_max_F[i],data$Bl_max_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE | is.na(data$Tl_min_M[i])==FALSE){
data_processed$Tl_min[i]<-min(c(data$Tl_min_F[i],data$Tl_max_F[i],data$Tl_min_M[i],data$Tl_max_M[i]))
data_processed$Tl_max[i]<-max(c(data$Tl_max_F[i],data$Tl_max_F[i],data$Tl_max_M[i],data$Tl_max_M[i]))
}
}
#now re-process data_processed to fill NAs in the main values, first by averaging male/female values, second (if sex averages are not available) by averaging sex-less min/max values. This overwrites the first pass summary version of data_processed with the second pass summary version
for (i in 1:(nrow(data_processed))){
#if there is a male/female average value, use its average as final value (assuming that female ranges also mean that there is a male range)
if(is.na(data_processed$Wt_g[i])==TRUE & is.na(data_processed$Wt_Av_F[i])==FALSE){
data_processed$Wt_g[i]<-mean(c(data_processed$Wt_Av_F[i], data_processed$Wt_Av_M[i]))
}
if(is.na(data_processed$Bl_mm[i])==TRUE & is.na(data_processed$Bl_Av_F[i])==FALSE){
data_processed$Bl_mm[i]<-mean(c(data_processed$Bl_Av_F[i], data_processed$Bl_Av_M[i]))
}
if(is.na(data_processed$Tl_mm[i])==TRUE & is.na(data_processed$Tl_Av_F[i])==FALSE){
data_processed$Tl_mm[i]<-mean(c(data_processed$Tl_Av_F[i], data_processed$Tl_Av_M[i]))
}
#if there are no male/female average values (regardles of newly created above or originally in the book; i.e. the male and female), average the ranges
if(is.na(data_processed$Wt_g[i])==TRUE & is.na(data_processed$Wt_Av_F[i])==TRUE){
data_processed$Wt_g[i]<-mean(c(data_processed$Wt_max[i], data_processed$Wt_min[i]))
}
if(is.na(data_processed$Bl_mm[i])==TRUE & is.na(data_processed$Bl_Av_F[i])==TRUE){
data_processed$Bl_mm[i]<-mean(c(data_processed$Bl_max[i], data_processed$Bl_min[i]))
}
if(is.na(data_processed$Tl_mm[i])==TRUE & is.na(data_processed$Tl_Av_F[i])==TRUE){
data_processed$Tl_mm[i]<-mean(c(data_processed$Tl_max[i], data_processed$Tl_min[i]))
}
}
write.csv(data_processed, file="../Data/Full_dataset.csv")
#these are just a few test rows with different scenarios
data_processed[50:64,]
data[50:64,]
data=read.csv("../Data/TableCode_example.csv", header=TRUE)
#make a matrix for all data but also add 3 columns for final Tl, Bl and Wt
#data_processed<-matrix(ncol=(ncol(data)), nrow=nrow(data))
#colnames(data_processed)<-c(colnames(data))
#rownames(data_processed)<-data$Species
# turn into data frame to feed into loop;
data_processed<-data
#if there are male/female ranges, provide their mean; this is clunky but I prefer to have the names written out to reduce human error in assigning column numbers
for (i in 1:length(data$Species)){
#if there are min/max values for males and females, average them unless an average is already given; this separates M/F because sometimes ranges are only given for one sex
if(is.na(data$Wt_min_F[i])==FALSE & is.na(data$Wt_Av_F[i]==TRUE)){
data_processed$Wt_Av_F[i]<-mean(c(data$Wt_min_F[i],data$Wt_max_F[i]))
}
if(is.na(data$Wt_min_M[i])==FALSE & is.na(data$Wt_Av_M[i]==TRUE)){
data_processed$Wt_Av_M[i]<-mean(c(data$Wt_min_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE & is.na(data$Bl_Av_F[i]==TRUE)){
data_processed$Bl_Av_F[i]<-mean(c(data$Bl_min_F[i],data$Bl_max_F[i]))
}
if(is.na(data$Bl_min_M[i])==FALSE & is.na(data$Bl_Av_M[i]==TRUE)){
data_processed$Bl_Av_M[i]<-mean(c(data$Bl_min_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE & is.na(data$Tl_Av_F[i]==TRUE)){
data_processed$Tl_Av_F[i]<-mean(c(data$Tl_min_F[i],data$Tl_max_F[i]))
}
if(is.na(data$Tl_min_M[i])==FALSE & is.na(data$Tl_Av_M[i]==TRUE)){
data_processed$Tl_Av_M[i]<-mean(c(data$Tl_min_M[i],data$Tl_max_M[i]))
}
# if males or females have ranges, enter the max and min for each species in the relevant column; this assumes that overall ranges are never given together with the more informative values by sex
if((is.na(data$Wt_min_F[i])==FALSE | is.na(data$Wt_min_M[i])==FALSE)){
data_processed$Wt_min[i]<-min(c(data$Wt_min_F[i],data$Wt_max_F[i],data$Wt_min_M[i],data$Wt_max_M[i]))
data_processed$Wt_max[i]<-max(c(data$Wt_max_F[i],data$Wt_max_F[i],data$Wt_max_M[i],data$Wt_max_M[i]))
}
if(is.na(data$Bl_min_F[i])==FALSE | is.na(data$Bl_min_M[i])==FALSE){
data_processed$Bl_min[i]<-min(c(data$Bl_min_F[i],data$Bl_max_F[i],data$Bl_min_M[i],data$Bl_max_M[i]))
data_processed$Bl_max[i]<-max(c(data$Bl_max_F[i],data$Bl_max_F[i],data$Bl_max_M[i],data$Bl_max_M[i]))
}
if(is.na(data$Tl_min_F[i])==FALSE | is.na(data$Tl_min_M[i])==FALSE){
data_processed$Tl_min[i]<-min(c(data$Tl_min_F[i],data$Tl_max_F[i],data$Tl_min_M[i],data$Tl_max_M[i]))
data_processed$Tl_max[i]<-max(c(data$Tl_max_F[i],data$Tl_max_F[i],data$Tl_max_M[i],data$Tl_max_M[i]))
}
}
#now re-process data_processed to fill NAs in the main values, first by averaging male/female values, second (if sex averages are not available) by averaging sex-less min/max values. This overwrites the first pass summary version of data_processed with the second pass summary version
for (i in 1:(nrow(data_processed))){
#if there is a male/female average value, use its average as final value (assuming that female ranges also mean that there is a male range)
if(is.na(data_processed$Wt_g[i])==TRUE & is.na(data_processed$Wt_Av_F[i])==FALSE){
data_processed$Wt_g[i]<-mean(c(data_processed$Wt_Av_F[i], data_processed$Wt_Av_M[i]))
}
if(is.na(data_processed$Bl_mm[i])==TRUE & is.na(data_processed$Bl_Av_F[i])==FALSE){
data_processed$Bl_mm[i]<-mean(c(data_processed$Bl_Av_F[i], data_processed$Bl_Av_M[i]))
}
if(is.na(data_processed$Tl_mm[i])==TRUE & is.na(data_processed$Tl_Av_F[i])==FALSE){
data_processed$Tl_mm[i]<-mean(c(data_processed$Tl_Av_F[i], data_processed$Tl_Av_M[i]))
}
#if there are no male/female average values (regardles of newly created above or originally in the book; i.e. the male and female), average the ranges
if(is.na(data_processed$Wt_g[i])==TRUE & is.na(data_processed$Wt_Av_F[i])==TRUE){
data_processed$Wt_g[i]<-mean(c(data_processed$Wt_max[i], data_processed$Wt_min[i]))
}
if(is.na(data_processed$Bl_mm[i])==TRUE & is.na(data_processed$Bl_Av_F[i])==TRUE){
data_processed$Bl_mm[i]<-mean(c(data_processed$Bl_max[i], data_processed$Bl_min[i]))
}
if(is.na(data_processed$Tl_mm[i])==TRUE & is.na(data_processed$Tl_Av_F[i])==TRUE){
data_processed$Tl_mm[i]<-mean(c(data_processed$Tl_max[i], data_processed$Tl_min[i]))
}
}
write.csv(data_processed, file="../Data/Full_dataset.csv")
#these are just a few test rows with different scenarios
data_processed[50:64,]
data[50:64,]
# The data, partition between marsupials and rodents
data=read.csv("../data/Full_dataset.csv")
#log10 transform all numerical data
#extract numerical columns
numcols=as.data.frame(data[,2:28])
#turn NAs into 1 so they turn into easily replaceable zeroes without messing with the logging
numcols[is.na(numcols)]<-1
#log transform
numcols_log10=log10(numcols)
#replace 0s with NAS again
numcols_log10[numcols_log10==0]<-NA
#replace original data with logged data. +1 because 2:34 is 33. There is probably a more elegant way of doing this
data[,2:(ncol(numcols)+1)]=numcols_log10
#partition datasets; this cannot be automated easily so need to check for accuracy by looking at dataset
#exclude wombats,koalas and marsupial moles who are outliers using grep (which returns the number of the row that has the species name).
data=data[-(c(grep("Vombatus_ursinus", data$Species),grep("Phascolarctos_cinereus", data$Species),grep("Lasiorhinus_latifrons", data$Species), grep("Notoryctes_typhlops", data$Species), grep("Notoryctes_caurinus", data$Species))),]
data$Clade <- droplevels(data$Clade, exclude= "Vombatiform")
#deleting all entries that have NAs in their main data and locomotor use; this means some species don't have weight data. T
data=data[-which(is.na( data$Tl_mm)) ,]
data=data[-which(is.na(data$Locomotor_use)),]
#make sure the species names are in the reows
rownames(data)<-data$Species
#running this in rmd I get an error message, but it does not seem to impact on the output
#134 species left; 14 newly identified species not present on tree but each of them are represented as close sister groups
tree=read.nexus("../Data/MayCollando_Marsupial_tree.nex")
library(ape)
library(geiger)
#134 species left; 14 newly identified species not present on tree but each of them are represented as close sister groups
tree=read.nexus("../Data/MayCollando_Marsupial_tree.nex")
namecheck=name.check(tree,data)
tree_synch=drop.tip(tree,namecheck$tree_not_data)
data_synch= data[-which(rownames(data) %in% namecheck$data_not_tree),]
name.check(tree_synch,data_synch)
#matching the order of tip labels to the tree
match(tree_synch$tip.label,data_synch$Species)
data_synch <-data_synch [,][match(tree_synch$tip.label,data_synch$Species),]
#Check that the re-ordering works
tree_synch$tip.label==data_synch$Species
#Some Petrogale branches are unresolved - hence, need to split these branches using multi2di
is.binary(tree_synch)
tree_synch <- multi2di(tree_synch, random = FALSE)
is.binary(tree_synch)
mf_data=data_synch[which(data_synch$Tl_Av_F !="NA"),]
mf_data=mf_data[which(mf_data$Wt_Av_F !="NA"),]
#this will give an error if name.check is OK - or at least I only encountered this error if this was the case
mf_datatree=drop.tip(tree_synch, name.check(tree_synch,mf_data)$tree_not_data )
mf_data=data_synch[which(data_synch$Tl_Av_F !="NA"),]
mf_data=mf_data[which(mf_data$Wt_Av_F !="NA"),]
mf_datatree=drop.tip(tree_synch, name.check(tree_synch,mf_data)$tree_not_data )
#putting all outputs and the initial processed input (dataFull) into one RDA
dataFull<-data
data<-data_synch
tree<-tree_synch
save(dataFull,data,tree, mf_data,mf_datatree, file = "../Data/Processed_Data_for_Pgls.rda")
#clean up environemtn
remove(data_synch,tree_synch)
